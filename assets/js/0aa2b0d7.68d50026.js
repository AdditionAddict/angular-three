"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[915],{9613:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>h});var a=n(9496);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},m=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,m=i(e,["components","mdxType","originalType","parentName"]),c=p(n),u=r,h=c["".concat(s,".").concat(u)]||c[u]||d[u]||o;return n?a.createElement(h,l(l({ref:t},m),{},{components:n})):a.createElement(h,l({ref:t},m))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,l=new Array(o);l[0]=u;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i[c]="string"==typeof e?e:r,l[1]=i;for(var p=2;p<o;p++)l[p]=n[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},7791:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>c,frontMatter:()=>o,metadata:()=>i,toc:()=>p});var a=n(4778),r=(n(9496),n(9613));const o={id:"custom-renderer",title:"Custom Renderer",sidebar_label:"Custom Renderer"},l=void 0,i={unversionedId:"api/custom-renderer",id:"api/custom-renderer",title:"Custom Renderer",description:"Throughout this documentation, when we talk about Custom Renderer, we mean the Angular Custom Renderer implementation, not THREE.js Renderer",source:"@site/docs/api/custom-renderer.mdx",sourceDirName:"api",slug:"/api/custom-renderer",permalink:"/docs/api/custom-renderer",draft:!1,editUrl:"https://github.com/angular-threejs/angular-three/tree/main/apps/documentation/docs/api/custom-renderer.mdx",tags:[],version:"current",frontMatter:{id:"custom-renderer",title:"Custom Renderer",sidebar_label:"Custom Renderer"},sidebar:"docs",previous:{title:"Canvas",permalink:"/docs/api/canvas"},next:{title:"NgtArgs",permalink:"/docs/api/directives/args"}},s={},p=[{value:"Custom Element tags",id:"custom-element-tags",level:2},{value:"<code>CUSTOM_ELEMENTS_SCHEMA</code>",id:"custom_elements_schema",level:3},{value:"Catalogue",id:"catalogue",level:2},{value:"THREE.js Inputs",id:"threejs-inputs",level:2},{value:"Short-cuts",id:"short-cuts",level:3},{value:"<code>set()</code>",id:"set",level:4},{value:"<code>setScalar()</code>",id:"setscalar",level:4},{value:"NGT Inputs",id:"ngt-inputs",level:2},{value:"<code>attach</code>",id:"attach",level:3},{value:"Static value",id:"static-value",level:4},{value:"Dynamic value",id:"dynamic-value",level:4},{value:"<code>NgtAttachFunction</code>",id:"ngtattachfunction",level:4},{value:"<code>priority</code>",id:"priority",level:3},{value:"<code>rawValue</code>",id:"rawvalue",level:3},{value:"<code>ref</code>",id:"ref",level:3},{value:"Outputs",id:"outputs",level:2},{value:"Object3D Events",id:"object3d-events",level:3},{value:"<code>beforeRender</code>",id:"beforerender",level:3},{value:"Render Priority",id:"render-priority",level:4},{value:"<code>afterAttach</code>",id:"afterattach",level:3},{value:"<code>afterUpdate</code>",id:"afterupdate",level:3}],m={toc:p};function c(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"Throughout this documentation, when we talk about ",(0,r.kt)("strong",{parentName:"p"},"Custom Renderer"),", we mean the Angular Custom Renderer implementation, not THREE.js Renderer")),(0,r.kt)("h2",{id:"custom-element-tags"},"Custom Element tags"),(0,r.kt)("p",null,"Since NGT is an ",(0,r.kt)("a",{parentName:"p",href:"https://angular.io/api/core/Renderer2"},"Angular Custom Renderer"),", we can control the ",(0,r.kt)("em",{parentName:"p"},"tags")," on the template.\nThanks to that, we can take a set of Custom Element tags and create corresponding THREE.js entities from those tags."),(0,r.kt)("p",null,"The convention of these Custom Element tags is: ",(0,r.kt)("inlineCode",{parentName:"p"},"ngt-three-js-class-in-kebab-case")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ngt-mesh")," -> ",(0,r.kt)("inlineCode",{parentName:"li"},"THREE.Mesh")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ngt-box-geometry")," -> ",(0,r.kt)("inlineCode",{parentName:"li"},"THREE.BoxGeometry")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ngt-lOD")," -> ",(0,r.kt)("inlineCode",{parentName:"li"},"THREE.LOD"))),(0,r.kt)("h3",{id:"custom_elements_schema"},(0,r.kt)("inlineCode",{parentName:"h3"},"CUSTOM_ELEMENTS_SCHEMA")),(0,r.kt)("p",null,"At the moment, Angular ",(0,r.kt)("strong",{parentName:"p"},"does not")," support userland ",(0,r.kt)("inlineCode",{parentName:"p"},"schemas"),". Hence, we need to rely on ",(0,r.kt)("inlineCode",{parentName:"p"},"CUSTOM_ELEMENTS_SCHEMA")," to compile our\napplication when using Custom Elements tag"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"@Component({\n    template: `...`,\n    schemas: [CUSTOM_ELEMENTS_SCHEMA],\n})\nexport class SceneGraph {}\n")),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"Only the Components that use Custom Element tags in their template needs ",(0,r.kt)("inlineCode",{parentName:"p"},"CUSTOM_ELEMENTS_SCHEMA"),". The Angular Compiler will\nthrow compilation errors if we violate.")),(0,r.kt)("h2",{id:"catalogue"},"Catalogue"),(0,r.kt)("p",null,"In order to map Custom Element tags to THREE.js entities, NGT creates an internal ",(0,r.kt)("inlineCode",{parentName:"p"},"catalogue")," to keep a dictionary of THREE.js entities.\nThis is done so the consumers ",(0,r.kt)("strong",{parentName:"p"},"do not")," have to include the whole THREE.js namespace in their application all the time."),(0,r.kt)("p",null,"To add THREE.js entities to this ",(0,r.kt)("inlineCode",{parentName:"p"},"catalogue"),", consumers use ",(0,r.kt)("inlineCode",{parentName:"p"},"extend()")," function; ideally at the beginning of the ",(0,r.kt)("inlineCode",{parentName:"p"},"SceneGraph")," component"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="scene-graph.component.ts"',title:'"scene-graph.component.ts"'},"import { extend } from 'angular-three';\n\n// call extend here\nextend({ Mesh, BoxGeometry });\n\n@Component({\n    /*...*/\n})\nexport class SceneGraph {} // SceneGraph can be named anything\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"@Component({\n    template: '<ngt-canvas [sceneGraph]=\"SceneGraph\" />',\n    imports: [NgtCanvas],\n})\nexport class SomeFeatureComponent {\n    readonly SceneGraph = SceneGraph; // import SceneGraph component above\n}\n")),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},"It is ok to call ",(0,r.kt)("inlineCode",{parentName:"li"},"extend()")," multiple times with duplications"),(0,r.kt)("li",{parentName:"ul"},"It is ok to call ",(0,r.kt)("inlineCode",{parentName:"li"},"extend(THREE)")," once to include the entire THREE.js namespace. However, the bundle will also include the entire THREE.js namespace"))),(0,r.kt)("h2",{id:"threejs-inputs"},"THREE.js Inputs"),(0,r.kt)("p",null,"We can pass in any THREE.js entities' properties as Inputs to the Custom Element tags."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-html"},'<ngt-mesh [position]="[1, 1, 1]" [scale]="1.5" [castShadow]="true">\n    <ngt-mesh-basic-material color="red" [wireframe]="true" />\n</ngt-mesh>\n<ngt-ambient-light [intensity]="0.5" />\n')),(0,r.kt)("p",null,"Due to limitations of Angular schemas, we do not have intellisense support here. The best documentation for these Inputs is ",(0,r.kt)("a",{parentName:"p",href:"https://threejs.org"},"THREE.js Documentatation")),(0,r.kt)("h3",{id:"short-cuts"},"Short-cuts"),(0,r.kt)("h4",{id:"set"},(0,r.kt)("inlineCode",{parentName:"h4"},"set()")),(0,r.kt)("p",null,"All Inputs whose underlying object has a ",(0,r.kt)("inlineCode",{parentName:"p"},".set()")," can accept the same arguments as ",(0,r.kt)("inlineCode",{parentName:"p"},"set()"),". For example, ",(0,r.kt)("inlineCode",{parentName:"p"},"THREE.Color#set")," can accept\na CSS-like color string. Hence, we can pass ",(0,r.kt)("inlineCode",{parentName:"p"},'color="red"')," instead of ",(0,r.kt)("inlineCode",{parentName:"p"},'[color]="color"')," (where ",(0,r.kt)("inlineCode",{parentName:"p"},"color = new THREE.Color('red')")," in our Component code)"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-html"},'<ngt-mesh-basic-material color="red" />\n')),(0,r.kt)("h4",{id:"setscalar"},(0,r.kt)("inlineCode",{parentName:"h4"},"setScalar()")),(0,r.kt)("p",null,"All Inputs whose underlying object has a ",(0,r.kt)("inlineCode",{parentName:"p"},".setScalar()")," can accept the same arguments as ",(0,r.kt)("inlineCode",{parentName:"p"},"setScalar()")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-html"},'\x3c!-- equivalent to [position]="[10, 10, 10]" --\x3e\n<ngt-mesh [position]="10" />\n')),(0,r.kt)("p",null,"There are other shortcuts like ",(0,r.kt)("inlineCode",{parentName:"p"},"copy()"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"fromArray()")," etc... The concept is the same but those aren't used as nearly common as ",(0,r.kt)("inlineCode",{parentName:"p"},"set()")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"setScalar()")),(0,r.kt)("h2",{id:"ngt-inputs"},"NGT Inputs"),(0,r.kt)("p",null,"In addition to Inputs that are THREE.js entities' properties, there are several Inputs that are unique to NGT Custom Renderer"),(0,r.kt)("h3",{id:"attach"},(0,r.kt)("inlineCode",{parentName:"h3"},"attach")),(0,r.kt)("p",null,"This Input is used to specify a property on the parent that this object should be ",(0,r.kt)("strong",{parentName:"p"},"attached")," to. Objects with ",(0,r.kt)("inlineCode",{parentName:"p"},"attach"),"\nwill be taken off their parent when they're not on the template (eg: under an ",(0,r.kt)("inlineCode",{parentName:"p"},"*ngIf")," or some other Structural Directive)"),(0,r.kt)("h4",{id:"static-value"},"Static value"),(0,r.kt)("p",null,"If the property on the parent is known and static, use ",(0,r.kt)("inlineCode",{parentName:"p"},"attach")," as ",(0,r.kt)("strong",{parentName:"p"},"Attribute Binding")," with ",(0,r.kt)("inlineCode",{parentName:"p"},"string")," values."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-html"},'<ngt-mesh>\n    <ngt-mesh-basic-material attach="material" />\n</ngt-mesh>\n')),(0,r.kt)("p",null,"This is equivalent to"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const mesh = new THREE.Mesh();\nconst material = new THREE.MeshBasicMaterial();\n\nmesh.material = material;\n")),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},"All Geometries have ",(0,r.kt)("inlineCode",{parentName:"li"},'attach="geometry"')," by default"),(0,r.kt)("li",{parentName:"ul"},"All Materials have ",(0,r.kt)("inlineCode",{parentName:"li"},'attach="material"')," by default")),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-html"},'<ngt-mesh>\n    \x3c!-- implicit attach="geometry" --\x3e\n    <ngt-box-geometry />\n    \x3c!-- implicit attach="material" --\x3e\n    <ngt-mesh-basic-material />\n</ngt-mesh>\n'))),(0,r.kt)("p",null,"We can also pass a ",(0,r.kt)("inlineCode",{parentName:"p"},"dotted.path")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"attach")," if the property is nested"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-html"},'<ngt-spot-light [castShadow]="true">\n    <ngt-vector2 attach="shadow.mapSize" />\n</ngt-spot-light>\n')),(0,r.kt)("p",null,"This is equivalent to"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const spotLight = new THREE.SpotLight();\nspotLight.castShadow = true;\n\nconst vector2 = new THREE.Vector2();\n// shortcut is still applied automatically\nspotLight.shadow.mapSize.copy(vector2);\n")),(0,r.kt)("h4",{id:"dynamic-value"},"Dynamic value"),(0,r.kt)("p",null,"If we need to pass a dynamic value to ",(0,r.kt)("inlineCode",{parentName:"p"},"attach"),", use ",(0,r.kt)("inlineCode",{parentName:"p"},"attach")," as ",(0,r.kt)("strong",{parentName:"p"},"Property Binding")," with ",(0,r.kt)("inlineCode",{parentName:"p"},"Array<string | number>")," values"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-html"},'<ngt-mesh>\n    <ngt-box-geometry />\n    \x3c!-- ngForRepeat is an NGT directive. We\'ll learn about it in a different section --\x3e\n    <ngt-mesh-lambert-material *ngFor="let i; repeat 6" [attach]="[\'material\', i]" />\n</ngt-mesh>\n')),(0,r.kt)("p",null,"This is equivalent to:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const mesh = new THREE.Mesh();\nconst geometry = new THREE.BoxGeometry();\n\nmesh.geometry = geometry;\nmesh.material = [];\n\nfor (let i = 0; i < 6; i++) {\n    const material = new THREE.MeshLambertMaterial();\n    mesh.material[i] = material;\n}\n")),(0,r.kt)("h4",{id:"ngtattachfunction"},(0,r.kt)("inlineCode",{parentName:"h4"},"NgtAttachFunction")),(0,r.kt)("p",null,"Optionally, we can also pass an ",(0,r.kt)("inlineCode",{parentName:"p"},"NgtAttachFunction")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"[attach]"),". When this is the case, we are responsible for ",(0,r.kt)("strong",{parentName:"p"},"attaching")," the child onto the parent\nas well as ",(0,r.kt)("strong",{parentName:"p"},"de-attaching")," (clean-up phase)"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// we can import this utility from 'angular-three'\nimport { createAttachFunction } from 'angular-three':\n\n@Component({\n    template: `\n        <ngt-mesh>\n            <ngt-mesh-basic-material [attach]=\"attachFn\" />\n        </ngt-mesh>\n    `,\n})\nexport class SceneGraph {\n    // \"store\" is the NgtStore, which has all information about the NgtCanvas\n    readonly attachFn = createAttachFunction<Mesh, MeshBasicMaterial>(({ parent, child /*, store */ }) => {\n        const oldMaterial = parent.material;\n        parent.material = child;\n        // return a clean-up function that will be called when `ngt-mesh-basic-material` is destroyed\n        return () => {\n            parent.material = oldMaterial;\n        };\n    });\n}\n")),(0,r.kt)("h3",{id:"priority"},(0,r.kt)("inlineCode",{parentName:"h3"},"priority")),(0,r.kt)("p",null,"See ",(0,r.kt)("a",{parentName:"p",href:"#render-priority"},"Render Priority")),(0,r.kt)("h3",{id:"rawvalue"},(0,r.kt)("inlineCode",{parentName:"h3"},"rawValue")),(0,r.kt)("p",null,"See ",(0,r.kt)("a",{parentName:"p",href:"./raw-value"},"Raw Value")),(0,r.kt)("h3",{id:"ref"},(0,r.kt)("inlineCode",{parentName:"h3"},"ref")),(0,r.kt)("p",null,"See ",(0,r.kt)("a",{parentName:"p",href:"./ref"},"Ref")),(0,r.kt)("h2",{id:"outputs"},"Outputs"),(0,r.kt)("h3",{id:"object3d-events"},"Object3D Events"),(0,r.kt)("p",null,"All of the following Outputs will trigger Change Detection upon invoked. This is intentional as we usually update Component's state with these Events."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"name"),(0,r.kt)("th",{parentName:"tr",align:null},"description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"click"),(0,r.kt)("td",{parentName:"tr",align:null},"If observed, emits when the object is clicked")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"contextmenu"),(0,r.kt)("td",{parentName:"tr",align:null},"If observed, emits when the object is right-clicked")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"dblclick"),(0,r.kt)("td",{parentName:"tr",align:null},"If observed, emits when the object is double clicked")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"pointerup"),(0,r.kt)("td",{parentName:"tr",align:null},"If observed, emits when the pointer moves up while on the object")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"pointerdown"),(0,r.kt)("td",{parentName:"tr",align:null},"If observed, emits when the pointer moves down while on the object")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"pointerover"),(0,r.kt)("td",{parentName:"tr",align:null},"If observed, emits when the pointer is over the object")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"pointerout"),(0,r.kt)("td",{parentName:"tr",align:null},"If observed, emits when the pointer gets on then out of the object")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"pointerenter"),(0,r.kt)("td",{parentName:"tr",align:null},"If observed, emits when the pointer gets on the object")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"pointerleave"),(0,r.kt)("td",{parentName:"tr",align:null},"If observed, emits when the pointer gets on then out of the object")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"pointermove"),(0,r.kt)("td",{parentName:"tr",align:null},"If observed, emits when the pointer moves while on the object")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"pointermissed"),(0,r.kt)("td",{parentName:"tr",align:null},"If observed, emits when the pointer misses the object")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"pointercancel"),(0,r.kt)("td",{parentName:"tr",align:null},"If observed, emits when the current pointer event gets cancelled")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"wheel"),(0,r.kt)("td",{parentName:"tr",align:null},"If observed, emits when the wheel is acted on when on the object")))),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"The events system in NGT is completely ported from R3F. For more information, please check ",(0,r.kt)("a",{parentName:"p",href:"https://docs.pmnd.rs/react-three-fiber/api/events"},"React Three Fiber Events"))),(0,r.kt)("h3",{id:"beforerender"},(0,r.kt)("inlineCode",{parentName:"h3"},"beforeRender")),(0,r.kt)("p",null,"To register a callback in the animation loop, we can listen for ",(0,r.kt)("inlineCode",{parentName:"p"},"(beforeRender)")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'@Component({\n    template: `<ngt-mesh (beforeRender)="onBeforeRender($any($event))" />`,\n})\nexport class SceneGraph {\n    onBeforeRender(event: NgtBeforeRenderEvent<Mesh>) {\n        // call per frame, will not trigger Change Detection\n    }\n}\n')),(0,r.kt)("p",null,"When the element is destroyed, ",(0,r.kt)("inlineCode",{parentName:"p"},"(beforeRender)")," is unregistered automatically."),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"We use ",(0,r.kt)("inlineCode",{parentName:"p"},"$any($event)")," because of Angular limitations on ",(0,r.kt)("inlineCode",{parentName:"p"},"CUSTOM_ELEMENTS_SCHEMA"))),(0,r.kt)("h4",{id:"render-priority"},"Render Priority"),(0,r.kt)("p",null,"By default, NGT renders the scene on every frame. If we need to control this process, we can pass ",(0,r.kt)("inlineCode",{parentName:"p"},"priority")," as ",(0,r.kt)("strong",{parentName:"p"},"Attribute Binding")," with number-string values\nto any object whose ",(0,r.kt)("inlineCode",{parentName:"p"},"(beforeRender)")," is being listened to. When a ",(0,r.kt)("inlineCode",{parentName:"p"},"priority")," is set, we are responsible to render our scene now."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'@Component({\n    template: `\n        <ngt-mesh priority="1" (beforeRender)="onBeforeRender($any($event))" />\n        <ngt-mesh priority="2" (beforeRender)="onOtherBeforeRender($any($event))" />\n    `,\n})\nexport class SceneGraph {\n    onBeforeRender(event: NgtBeforeRenderEvent<Mesh>) {\n        const { gl, scene, camera } = event.state;\n        // do something\n        gl.render(scene, camera);\n        // do something else\n    }\n\n    onOtherBeforeRender(event: NgtBeforeRenderEvent<Mesh>) {\n        // this runs after the above beforeRender\n    }\n}\n')),(0,r.kt)("h3",{id:"afterattach"},(0,r.kt)("inlineCode",{parentName:"h3"},"afterAttach")),(0,r.kt)("p",null,"This event emits after the child ",(0,r.kt)("strong",{parentName:"p"},"has been attached")," to the parent"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'@Component({\n    template: `\n        <ngt-mesh>\n            <ngt-mesh-basic-material attach="material" (afterAttach)="onAfterAttach($any($event))" />\n        </ngt-mesh>\n    `,\n})\nexport class SceneGraph {\n    onAfterAttach(event: NgtAfterAttach<Mesh, MeshBasicMaterial>) {}\n}\n')),(0,r.kt)("h3",{id:"afterupdate"},(0,r.kt)("inlineCode",{parentName:"h3"},"afterUpdate")),(0,r.kt)("p",null,"This event emits after an object is updated"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'@Component({\n    template: ` <ngt-mesh (afterUpdate)="onAfterUpdate($any($event))" [position]="[0, 1, 2]" /> `,\n})\nexport class SceneGraph {\n    onAfterUpdate(event: Mesh) {}\n}\n')))}c.isMDXComponent=!0}}]);