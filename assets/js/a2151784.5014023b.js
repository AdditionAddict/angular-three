"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[711],{9613:(e,n,t)=>{t.d(n,{Zo:()=>m,kt:()=>h});var a=t(9496);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=a.createContext({}),p=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},m=function(e){var n=p(e.components);return a.createElement(s.Provider,{value:n},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),c=p(t),d=r,h=c["".concat(s,".").concat(d)]||c[d]||u[d]||o;return t?a.createElement(h,i(i({ref:n},m),{},{components:t})):a.createElement(h,i({ref:n},m))}));function h(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,i=new Array(o);i[0]=d;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l[c]="string"==typeof e?e:r,i[1]=l;for(var p=2;p<o;p++)i[p]=t[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},8627:(e,n,t)=>{t.d(n,{Z:()=>i});var a=t(9496),r=t(5924);const o="tabItem_pxx2";function i(e){let{children:n,hidden:t,className:i}=e;return a.createElement("div",{role:"tabpanel",className:(0,r.Z)(o,i),hidden:t},n)}},7451:(e,n,t)=>{t.d(n,{Z:()=>v});var a=t(4778),r=t(9496),o=t(5924),i=t(4992),l=t(3442),s=t(6755),p=t(6573),m=t(3555);function c(e){return function(e){return r.Children.map(e,(e=>{if(!e||(0,r.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}(e).map((e=>{let{props:{value:n,label:t,attributes:a,default:r}}=e;return{value:n,label:t,attributes:a,default:r}}))}function u(e){const{values:n,children:t}=e;return(0,r.useMemo)((()=>{const e=n??c(t);return function(e){const n=(0,p.l)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,t])}function d(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function h(e){let{queryString:n=!1,groupId:t}=e;const a=(0,l.k6)(),o=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:n,groupId:t});return[(0,s._X)(o),(0,r.useCallback)((e=>{if(!o)return;const n=new URLSearchParams(a.location.search);n.set(o,e),a.replace({...a.location,search:n.toString()})}),[o,a])]}function g(e){const{defaultValue:n,queryString:t=!1,groupId:a}=e,o=u(e),[i,l]=(0,r.useState)((()=>function(e){let{defaultValue:n,tabValues:t}=e;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!d({value:n,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const a=t.find((e=>e.default))??t[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:n,tabValues:o}))),[s,p]=h({queryString:t,groupId:a}),[c,g]=function(e){let{groupId:n}=e;const t=function(e){return e?`docusaurus.tab.${e}`:null}(n),[a,o]=(0,m.Nk)(t);return[a,(0,r.useCallback)((e=>{t&&o.set(e)}),[t,o])]}({groupId:a}),k=(()=>{const e=s??c;return d({value:e,tabValues:o})?e:null})();(0,r.useLayoutEffect)((()=>{k&&l(k)}),[k]);return{selectedValue:i,selectValue:(0,r.useCallback)((e=>{if(!d({value:e,tabValues:o}))throw new Error(`Can't select invalid tab value=${e}`);l(e),p(e),g(e)}),[p,g,o]),tabValues:o}}var k=t(8772);const N="tabList_f5DR",f="tabItem_f81j";function b(e){let{className:n,block:t,selectedValue:l,selectValue:s,tabValues:p}=e;const m=[],{blockElementScrollPositionUntilNextRender:c}=(0,i.o5)(),u=e=>{const n=e.currentTarget,t=m.indexOf(n),a=p[t].value;a!==l&&(c(n),s(a))},d=e=>{let n=null;switch(e.key){case"Enter":u(e);break;case"ArrowRight":{const t=m.indexOf(e.currentTarget)+1;n=m[t]??m[0];break}case"ArrowLeft":{const t=m.indexOf(e.currentTarget)-1;n=m[t]??m[m.length-1];break}}n?.focus()};return r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.Z)("tabs",{"tabs--block":t},n)},p.map((e=>{let{value:n,label:t,attributes:i}=e;return r.createElement("li",(0,a.Z)({role:"tab",tabIndex:l===n?0:-1,"aria-selected":l===n,key:n,ref:e=>m.push(e),onKeyDown:d,onClick:u},i,{className:(0,o.Z)("tabs__item",f,i?.className,{"tabs__item--active":l===n})}),t??n)})))}function C(e){let{lazy:n,children:t,selectedValue:a}=e;const o=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){const e=o.find((e=>e.props.value===a));return e?(0,r.cloneElement)(e,{className:"margin-top--md"}):null}return r.createElement("div",{className:"margin-top--md"},o.map(((e,n)=>(0,r.cloneElement)(e,{key:n,hidden:e.props.value!==a}))))}function E(e){const n=g(e);return r.createElement("div",{className:(0,o.Z)("tabs-container",N)},r.createElement(b,(0,a.Z)({},e,n)),r.createElement(C,(0,a.Z)({},e,n)))}function v(e){const n=(0,k.Z)();return r.createElement(E,(0,a.Z)({key:String(n)},e))}},9459:(e,n,t)=>{t.d(n,{Z:()=>r});var a=t(9496);function r(e){let{src:n,srcId:t,title:r}=e;const o=t?`https://stackblitz.com/edit/angular-three-demo-template-${t}`:n;return a.createElement("iframe",{className:"code-demo",src:o.concat("?ctl=1&embed=1&file=src/app/scene.component.ts&hideExplorer=1&hideNavigation=1&view=preview"),title:"angular_three_".concat(r||Math.random().toString())})}},6110:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>p,default:()=>h,frontMatter:()=>s,metadata:()=>m,toc:()=>u});var a=t(4778),r=(t(9496),t(9613)),o=t(7451),i=t(8627),l=t(9459);const s={id:"first-scene",title:"Our first scene",sidebar_label:"First Scene"},p=void 0,m={unversionedId:"getting-started/first-scene",id:"getting-started/first-scene",title:"Our first scene",description:"This tutorial will help us setup our first NGT scene and introduce us to some of its core concepts.",source:"@site/docs/getting-started/first-scene.mdx",sourceDirName:"getting-started",slug:"/getting-started/first-scene",permalink:"/docs/getting-started/first-scene",draft:!1,editUrl:"https://github.com/angular-threejs/angular-three/tree/main/apps/documentation/docs/getting-started/first-scene.mdx",tags:[],version:"current",frontMatter:{id:"first-scene",title:"Our first scene",sidebar_label:"First Scene"},sidebar:"docs",previous:{title:"Installation",permalink:"/docs/getting-started/installation"},next:{title:"Canvas",permalink:"/docs/api/canvas"}},c={},u=[{value:"Create a root component for our Scene graph",id:"create-a-root-component-for-our-scene-graph",level:2},{value:"Set up the Canvas",id:"set-up-the-canvas",level:2},{value:"Extend THREE.js catalogue",id:"extend-threejs-catalogue",level:2},{value:"Adding a Mesh",id:"adding-a-mesh",level:2},{value:"Animating our cube",id:"animating-our-cube",level:2},{value:"Componentize our cube",id:"componentize-our-cube",level:2},{value:"Adding lights",id:"adding-lights",level:2},{value:"Bonus: Taking control of the camera",id:"bonus-taking-control-of-the-camera",level:2},{value:"What&#39;s next?",id:"whats-next",level:2}],d={toc:u};function h(e){let{components:n,...t}=e;return(0,r.kt)("wrapper",(0,a.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This tutorial will help us setup our first NGT scene and introduce us to some of its core concepts."),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},"We are using Inline Template syntax for this tutorial"),(0,r.kt)("li",{parentName:"ul"},"We will put everything in ",(0,r.kt)("inlineCode",{parentName:"li"},"app.component.ts")," for simplicity"))),(0,r.kt)("h2",{id:"create-a-root-component-for-our-scene-graph"},"Create a root component for our Scene graph"),(0,r.kt)("p",null,"Let's start by creating a Component as the root of our Scene graph. We'll put the component in ",(0,r.kt)("inlineCode",{parentName:"p"},"app.component.ts")," for now"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="app.component.ts"',title:'"app.component.ts"'},"import { Component, CUSTOM_ELEMENTS_SCHEMA } from '@angular/core';\n\n@Component({\n    standalone: true,\n    template: ``,\n    schemas: [CUSTOM_ELEMENTS_SCHEMA],\n})\nexport class SceneGraph {}\n\n@Component({\n    /*...*/\n})\nexport class AppComponent {}\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"template")," is intentionally left empty, we'll fill it out later."),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"selector")," is intentionally left out because we'll not render our ",(0,r.kt)("inlineCode",{parentName:"li"},"SceneGraph")," component on the template."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"CUSTOM_ELEMENTS_SCHEMA")," is required because Angular does not support custom schemas so our Custom Elements won't work without it.")),(0,r.kt)("h2",{id:"set-up-the-canvas"},"Set up the Canvas"),(0,r.kt)("p",null,"The scene graph in NGT starts with ",(0,r.kt)("inlineCode",{parentName:"p"},"<ngt-canvas>"),". Let's render ",(0,r.kt)("inlineCode",{parentName:"p"},"<ngt-canvas>")," on our ",(0,r.kt)("inlineCode",{parentName:"p"},"app.component.ts")," template.\nMake sure to import ",(0,r.kt)("inlineCode",{parentName:"p"},"NgtCanvas")," from ",(0,r.kt)("inlineCode",{parentName:"p"},"angular-three")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="app.component.ts"',title:'"app.component.ts"'},"import { Component, CUSTOM_ELEMENTS_SCHEMA } from '@angular/core';\n// highlight-next-line\nimport { NgtCanvas } from 'angular-three';\n\n@Component({\n    /*...*/\n})\nexport class SceneGraph {}\n\n@Component({\n    selector: 'app-root',\n    standalone: true,\n    // highlight-start\n    template: `<ngt-canvas [sceneGraph]=\"SceneGraph\" />`,\n    imports: [NgtCanvas],\n    // highlight-end\n})\nexport class AppComponent {\n    // highlight-next-line\n    readonly SceneGraph = SceneGraph;\n}\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"<ngt-canvas>")," has a ",(0,r.kt)("strong",{parentName:"li"},"required")," input ",(0,r.kt)("inlineCode",{parentName:"li"},"[sceneGraph]")," which accepts a Component class. We pass our ",(0,r.kt)("inlineCode",{parentName:"li"},"SceneGraph")," component into that input.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"ngt-canvas")," sets up the following:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"A ",(0,r.kt)("inlineCode",{parentName:"li"},"WebGLRenderer"),", a default ",(0,r.kt)("inlineCode",{parentName:"li"},"Scene"),", and a default ",(0,r.kt)("inlineCode",{parentName:"li"},"PerspectiveCamera")),(0,r.kt)("li",{parentName:"ul"},"A render loop that renders our scene evere frame outside of Change Detection"),(0,r.kt)("li",{parentName:"ul"},"A ",(0,r.kt)("inlineCode",{parentName:"li"},"window:resize")," listener that updates our Renderer and Camera when the viewport is resized")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"ngt-canvas")," renders the ",(0,r.kt)("inlineCode",{parentName:"p"},"SceneGraph")," input in a ",(0,r.kt)("em",{parentName:"p"},"detached")," environment from Angular Change Detection. It also provides the custom Angular Renderer\nto render THREE.js entities instead of DOM elements."),(0,r.kt)("p",null,"Next, we'll set some basic styles in ",(0,r.kt)("inlineCode",{parentName:"p"},"styles.css")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-css",metastring:'title="style.css"',title:'"style.css"'},"html,\nbody {\n    height: 100%;\n    width: 100%;\n    margin: 0;\n}\n")),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("inlineCode",{parentName:"p"},"ngt-canvas")," is designed to fit the parent container so we can control our 3D scene by adjusting the parent's dimensions."),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-html"},'<div class="canvas-container">\n    <ngt-canvas [sceneGraph]="..." />\n</div>\n'))),(0,r.kt)("h2",{id:"extend-threejs-catalogue"},"Extend THREE.js catalogue"),(0,r.kt)("p",null,'NGT is a custom Angular Renderer so it has to have a collection of "',(0,r.kt)("em",{parentName:"p"},"what to render"),'", we call it ',(0,r.kt)("strong",{parentName:"p"},"catalogue"),". By default, the catalogue is empty.\nWe can add elements to the catalogue by calling ",(0,r.kt)("inlineCode",{parentName:"p"},"extend()")," and pass in a dictionary of THREE entities."),(0,r.kt)("p",null,"The Renderer then maps the catalogue to Custom Element tags. The convention of our Custom Element tags is:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-html"},"<ngt-{name-of-the-THREE-element-kebab-case}></ngt-{name-of-the-THREE-element-kebab-case}>\n")),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"In Angular 15.1+, we can also use Self Closing tag ",(0,r.kt)("inlineCode",{parentName:"p"},"<ngt-{name-of-the-THREE-element-kebab-case} />"))),(0,r.kt)("p",null,"For example:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Mesh")," -> ",(0,r.kt)("inlineCode",{parentName:"li"},"ngt-mesh")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"BoxGeometry")," -> ",(0,r.kt)("inlineCode",{parentName:"li"},"ngt-box-geometry"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { extend } from 'angular-three';\nimport { Mesh } from 'three';\n\nextend({ Mesh });\n// if we want to render `<ngt-some-mesh>` then we can do\n// extend({ SomeMesh: Mesh })\n")),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"We can extend the entire THREE.js collection with ",(0,r.kt)("inlineCode",{parentName:"p"},"extend(THREE)")," but that will include everything from ",(0,r.kt)("inlineCode",{parentName:"p"},"THREE"),"\nnamespace in our bundle. For the purpose of this tutorial, we'll be using ",(0,r.kt)("inlineCode",{parentName:"p"},"extend(THREE)"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="app.component.ts"',title:'"app.component.ts"'},"import { Component, CUSTOM_ELEMENTS_SCHEMA } from '@angular/core';\n// highlight-start\nimport { NgtCanvas, extend } from 'angular-three';\nimport * as THREE from 'three';\n// highlight-end\n\n// highlight-next-line\nextend(THREE);\n\n/* the rest of the code */\n")),(0,r.kt)("h2",{id:"adding-a-mesh"},"Adding a Mesh"),(0,r.kt)("p",null,"Now that we have THREE.js in our catalogue, we are ready to render some THREE.js entities. Let's start with adding a ",(0,r.kt)("inlineCode",{parentName:"p"},"THREE.Mesh"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="app.component.ts"',title:'"app.component.ts"'},"import { Component, CUSTOM_ELEMENTS_SCHEMA } from '@angular/core';\nimport { NgtCanvas, extend } from 'angular-three';\nimport * as THREE from 'three';\n\nextend(THREE);\n\n@Component({\n    standalone: true,\n    template: `\n        // highlight-next-line\n        <ngt-mesh></ngt-mesh>\n    `,\n    schemas: [CUSTOM_ELEMENTS_SCHEMA],\n})\nexport class SceneGraph {}\n\n/* AppComponent code */\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"THREE.Mesh")," is one of the most fundamental objects in THREE.js. It is used to hold a ",(0,r.kt)("strong",{parentName:"p"},"Geometry")," and a ",(0,r.kt)("strong",{parentName:"p"},"Material"),"\nto represent a shape in the 3D space. For this tutorial, we'll use ",(0,r.kt)("inlineCode",{parentName:"p"},"BoxGeometry"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"MeshBasicMaterial")," to create a cube."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="app.component.ts"',title:'"app.component.ts"'},"/* imports */\n\nextend(THREE);\n\n@Component({\n    standalone: true,\n    template: `\n        <ngt-mesh>\n            // highlight-start\n            <ngt-box-geometry />\n            <ngt-mesh-basic-material />\n            // highlight-end\n        </ngt-mesh>\n    `,\n    schemas: [CUSTOM_ELEMENTS_SCHEMA],\n})\nexport class SceneGraph {}\n\n/* AppComponent code */\n")),(0,r.kt)("p",null,"At this point, we'll have something on the scene to look at."),(0,r.kt)(l.Z,{srcId:"qhgogp",mdxType:"CodeDemo"}),(0,r.kt)("h2",{id:"animating-our-cube"},"Animating our cube"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Animation-on-the-web-101"),": Change the object's properties little by little, frame by frame to animate it in an animation loop.")),(0,r.kt)("p",null,"That's right! NGT renders our Scene graph in an animation loop (typically 60FPS, or 60 frames per second). This means we\ncan change our cube's properties (eg: ",(0,r.kt)("inlineCode",{parentName:"p"},"rotation"),") little by little to ",(0,r.kt)("em",{parentName:"p"},"animate")," it. In NGT, we can use ",(0,r.kt)("inlineCode",{parentName:"p"},"(beforeRender)"),"\nevent binding to tap into this animation loop."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="app.component.ts"',title:'"app.component.ts"'},"/* imports */\n// highlight-next-line\nimport { NgtCanvas, extend, NgtBeforeRenderEvent } from 'angular-three';\n\nextend(THREE);\n\n@Component({\n    standalone: true,\n    template: `\n        <ngt-mesh\n            // highlight-next-line\n            (beforeRender)=\"onBeforeRender($any($event))\"\n        >\n            <ngt-box-geometry />\n            <ngt-mesh-basic-material />\n        </ngt-mesh>\n    `,\n    schemas: [CUSTOM_ELEMENTS_SCHEMA],\n})\nexport class SceneGraph {\n    // highlight-start\n    onBeforeRender(event: NgtBeforeRenderEvent<THREE.Mesh>) {\n        event.object.rotation.x += 0.01;\n    }\n    // highlight-end\n}\n\n/* AppComponent code */\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"We listen for ",(0,r.kt)("inlineCode",{parentName:"li"},"(beforeRender)")," on our ",(0,r.kt)("inlineCode",{parentName:"li"},"ngt-mesh")," with ",(0,r.kt)("inlineCode",{parentName:"li"},"onBeforeRender()")," handler."),(0,r.kt)("li",{parentName:"ul"},"We use ",(0,r.kt)("inlineCode",{parentName:"li"},"$any($event)")," due to Angular Language Service's limitation."),(0,r.kt)("li",{parentName:"ul"},"On ",(0,r.kt)("inlineCode",{parentName:"li"},"onBeforeRender()"),", we type ",(0,r.kt)("inlineCode",{parentName:"li"},"event")," with ",(0,r.kt)("inlineCode",{parentName:"li"},"NgtBeforeRenderEvent<THREE.Mesh>"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"event.state")," is the state of our Scene graph; mouse position, clock, delta, scene, camera, the GL renderer etc..."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"event.object")," is the instance of the object we're attaching ",(0,r.kt)("inlineCode",{parentName:"li"},"(beforeRender)")," on. In this case, it is a ",(0,r.kt)("inlineCode",{parentName:"li"},"THREE.Mesh")))),(0,r.kt)("li",{parentName:"ul"},"We change ",(0,r.kt)("inlineCode",{parentName:"li"},"rotation.x")," by incrementing it ",(0,r.kt)("inlineCode",{parentName:"li"},"0.01")," radian on every frame. The result is we have a spinning cube")),(0,r.kt)(l.Z,{srcId:"dnc3hb",mdxType:"CodeDemo"}),(0,r.kt)("p",null,"Wow, that was easy! Before we move on, let's pause for a moment to understand what is ",(0,r.kt)("em",{parentName:"p"},"happening")," here."),(0,r.kt)("p",null,"Here are the code of the above scene with Angular Three and plain THREE.js"),(0,r.kt)(o.Z,{mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"angular",label:"Angular Three",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { Component, CUSTOM_ELEMENTS_SCHEMA } from '@angular/core';\nimport { NgtCanvas, extend, NgtBeforeRenderEvent } from 'angular-three';\nimport * as THREE from 'three';\n\nextend(THREE);\n\n@Component({\n    standalone: true,\n    template: `\n        <ngt-mesh (beforeRender)=\"onBeforeRender($any($event))\">\n            <ngt-box-geometry />\n            <ngt-mesh-basic-material />\n        </ngt-mesh>\n    `,\n    schemas: [CUSTOM_ELEMENTS_SCHEMA],\n})\nexport class SceneGraph {\n    onBeforeRender(event: NgtBeforeRenderEvent<THREE.Mesh>) {\n        event.object.rotation.x += 0.01;\n    }\n}\n\n@Component({\n    selector: 'app-root',\n    standalone: true,\n    template: `<ngt-canvas [sceneGraph]=\"SceneGraph\" />`,\n    imports: [NgtCanvas],\n})\nexport class AppComponent {\n    readonly SceneGraph = SceneGraph;\n}\n"))),(0,r.kt)(i.Z,{value:"plain",label:"Plain THREE.js",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const scene = new THREE.Scene();\nconst camera = new THREE.PerspectiveCamera(75, document.clientWidth / document.clientHeight, 0.1, 1000);\n\nconst renderer = new THREE.WebGLRenderer({\n    antialiasing: true,\n    alpha: true,\n    powerPreference: 'high-power',\n});\nrenderer.setSize(document.clientWidth, document.clientHeight);\nrenderer.setPixelRatio(window.devicePixelRatio || 1);\ndocument.querySelector('app-root').appendChild(renderer.domElement);\n\nfunction resize() {\n    renderer.setSize(document.clientWidth, document.clientHeight);\n    renderer.setPixelRatio(window.devicePixelRatio || 1);\n    camera.aspect = document.clientWidth / document.clientHeight;\n    camera.updateProjectionMatrix();\n}\n\nwindow.addEventListener('resize', resize);\n// then setup window.removeEventListener('resize', resize) somewhere\n\nconst cube = new THREE.Mesh(new THREE.BoxGeometry(), new THREE.MeshBasicMaterial());\n\nscene.add(cube);\n\nfunction animate() {\n    requestAnimationFrame(animate);\n    cube.rotation.x += 0.01;\n    renderer.render(scene, camera);\n}\n\nanimate();\n")))),(0,r.kt)("p",null,"Plain THREE.js does not look so bad but it is ",(0,r.kt)("em",{parentName:"p"},"imperative"),". By leveraging Angular template, we can express our Scene in a\nmore ",(0,r.kt)("em",{parentName:"p"},"declarative")," manner. We can use Angular features like ",(0,r.kt)("inlineCode",{parentName:"p"},"*ngIf"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"*ngFor"),", other Directives, DI, and more to allow our Scene\nto be more ",(0,r.kt)("strong",{parentName:"p"},"dynamic"),". In addition, the THREE entities expressed in NGT are aware of their life-cycles which allows them\nto automatically clean up when they are ",(0,r.kt)("em",{parentName:"p"},"destroyed"),"."),(0,r.kt)("p",null,"Next section of this tutorial shows an even ",(0,r.kt)("em",{parentName:"p"},"better")," reason to use NGT."),(0,r.kt)("h2",{id:"componentize-our-cube"},"Componentize our cube"),(0,r.kt)("p",null,"Using Angular means we can make components out of our template. Let's do that for our cube"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"/* imports */\nextend(THREE);\n\n// highlight-start\n@Component({\n    selector: 'demo-cube',\n    standalone: true,\n    template: `\n        <ngt-mesh (beforeRender)=\"onBeforeRender($any($event))\">\n            <ngt-box-geometry />\n            <ngt-mesh-basic-material />\n        </ngt-mesh>\n    `,\n    schemas: [CUSTOM_ELEMENTS_SCHEMA],\n})\nexport class Cube {\n    onBeforeRender(event: NgtBeforeRenderEvent<THREE.Mesh>) {\n        event.object.rotation.x += 0.01;\n    }\n}\n// highlight-end\n\n@Component({\n    standalone: true,\n    // highlight-start\n    template: ` <demo-cube /> `,\n    imports: [Cube],\n    // highlight-end\n    schemas: [CUSTOM_ELEMENTS_SCHEMA],\n})\nexport class SceneGraph {}\n\n/* AppComponent code */\n")),(0,r.kt)("p",null,"Everything works as before but now we have a ",(0,r.kt)("inlineCode",{parentName:"p"},"Cube")," component that can have internal states.\nWe will add two states ",(0,r.kt)("inlineCode",{parentName:"p"},"hovered")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"active")," to our ",(0,r.kt)("inlineCode",{parentName:"p"},"Cube")," component"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"When we hover over the cube, we set ",(0,r.kt)("inlineCode",{parentName:"li"},"hovered")," to ",(0,r.kt)("inlineCode",{parentName:"li"},"true")," and vice versa"),(0,r.kt)("li",{parentName:"ul"},"When we click the cube, we toggle the ",(0,r.kt)("inlineCode",{parentName:"li"},"active")," state"),(0,r.kt)("li",{parentName:"ul"},"When ",(0,r.kt)("inlineCode",{parentName:"li"},"active"),", we make the cube bigger"),(0,r.kt)("li",{parentName:"ul"},"When ",(0,r.kt)("inlineCode",{parentName:"li"},"hovered"),", we change the color of the cube")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'/* imports */\nextend(THREE);\n\n@Component({\n    selector: \'demo-cube\',\n    standalone: true,\n    template: `\n        <ngt-mesh\n            (beforeRender)="onBeforeRender($any($event))"\n            // highlight-start\n            (click)="active = !active"\n            (pointerover)="hovered = true"\n            (pointerout)="hovered = false"\n            [scale]="active ? 1.5 : 1"\n            // highlight-end\n        >\n            <ngt-box-geometry />\n            // highlight-next-line\n            <ngt-mesh-basic-material [color]="hovered ? \'darkred\' : \'red\'" />\n        </ngt-mesh>\n    `,\n    schemas: [CUSTOM_ELEMENTS_SCHEMA],\n})\nexport class Cube {\n    // highlight-start\n    active = false;\n    hovered = false;\n    // highlight-end\n\n    onBeforeRender(event: NgtBeforeRenderEvent<THREE.Mesh>) {\n        event.object.rotation.x += 0.01;\n    }\n}\n\n/* SceneGraph code */\n\n/* AppComponent code */\n')),(0,r.kt)("p",null,"Familiar, right? This is one of the goals of NGT. Interact with the cube now and see the ",(0,r.kt)("em",{parentName:"p"},"magic")),(0,r.kt)(l.Z,{srcId:"chmpph",mdxType:"CodeDemo"}),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"(click)"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"(pointerover)"),", and ",(0,r.kt)("inlineCode",{parentName:"li"},"(pointerout)")," look like DOM events but they are not. These events are named as such\nto give a sense of familiarity to Angular developers."),(0,r.kt)("li",{parentName:"ul"},"These events automatically calls ",(0,r.kt)("inlineCode",{parentName:"li"},"changeDetectorRef.detectChanges")," so we can update states (eg: ",(0,r.kt)("inlineCode",{parentName:"li"},"hovered")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"active"),").")),(0,r.kt)("p",null,"Now that our cube is ",(0,r.kt)("em",{parentName:"p"},"interactive")," and ",(0,r.kt)("em",{parentName:"p"},"fun"),", we can render another ",(0,r.kt)("inlineCode",{parentName:"p"},"demo-cube")," to ",(0,r.kt)("em",{parentName:"p"},"double the fun"),". But first, we need to add a ",(0,r.kt)("inlineCode",{parentName:"p"},"position")," input\nso we can show both ",(0,r.kt)("inlineCode",{parentName:"p"},"Cube")," in different positions on the Scene."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'/* imports */\nextend(THREE);\n\n@Component({\n    selector: \'demo-cube\',\n    standalone: true,\n    template: `\n        <ngt-mesh\n            (beforeRender)="onBeforeRender($any($event))"\n            (click)="active = !active"\n            (pointerover)="hovered = true"\n            (pointerout)="hovered = false"\n            [scale]="active ? 1.5 : 1"\n            // highlight-next-line\n            [position]="position"\n        >\n            <ngt-box-geometry />\n            <ngt-mesh-basic-material [color]="hovered ? \'darkred\' : \'red\'" />\n        </ngt-mesh>\n    `,\n    schemas: [CUSTOM_ELEMENTS_SCHEMA],\n})\nexport class Cube {\n    // highlight-next-line\n    @Input() position = [0, 0, 0];\n\n    active = false;\n    hovered = false;\n\n    onBeforeRender(event: NgtBeforeRenderEvent<THREE.Mesh>) {\n        event.object.rotation.x += 0.01;\n    }\n}\n\n@Component({\n    standalone: true,\n    template: `\n        // highlight-start\n        <demo-cube [position]="[1.5, 0, 0]" />\n        <demo-cube [position]="[-1.5, 0, 0]" />\n        // highlight-end\n    `,\n    imports: [Cube],\n    schemas: [CUSTOM_ELEMENTS_SCHEMA],\n})\nexport class SceneGraph {}\n\n/* AppComponent code */\n')),(0,r.kt)("p",null,"and voila, we have 2 ",(0,r.kt)("inlineCode",{parentName:"p"},"Cube")," that have their own states, and reacting to events independently."),(0,r.kt)(l.Z,{srcId:"thz5yc",mdxType:"CodeDemo"}),(0,r.kt)("h2",{id:"adding-lights"},"Adding lights"),(0,r.kt)("p",null,"Our cubes are interactive, but they look bland. They don't look like 3D objects at the moment, because they lack Light Reflections."),(0,r.kt)("p",null,"First, let's switch out ",(0,r.kt)("inlineCode",{parentName:"p"},"<ngt-mesh-basic-material>")," for ",(0,r.kt)("inlineCode",{parentName:"p"},"<ngt-mesh-standard-material>")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-diff"},"/* imports */\nextend(THREE);\n\n@Component({\n    selector: 'demo-cube',\n    standalone: true,\n    template: `\n        <ngt-mesh\n            /* mesh properties/events */\n        >\n            <ngt-box-geometry />\n-           <ngt-mesh-basic-material [color]=\"hovered ? 'darkred' : 'red'\" />\n+           <ngt-mesh-standard-material [color]=\"hovered ? 'darkred' : 'red'\" />\n        </ngt-mesh>\n    `,\n    schemas: [CUSTOM_ELEMENTS_SCHEMA],\n})\nexport class Cube {\n    /* component code */\n}\n\n/* SceneGraph code */\n\n/* AppComponent code */\n")),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"We can check the Scene now and notice that our cubes are ",(0,r.kt)("em",{parentName:"p"},"pitch black"),".\nThis is because ",(0,r.kt)("inlineCode",{parentName:"p"},"MeshStandardMaterial"),' is a material that needs to be lit up by lights.\nImagine a dark room with no lights, any object would be black. Our scene background just happens to be "white" by default.')),(0,r.kt)("p",null,"Next, let's start adding lights to our ",(0,r.kt)("inlineCode",{parentName:"p"},"SceneGraph")," component"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'/* imports */\nextend(THREE);\n\n/* Cube code */\n\n@Component({\n    standalone: true,\n    template: `\n        // highlight-start\n        <ngt-ambient-light [intensity]="0.5" />\n        <ngt-spot-light [position]="10" [angle]="0.15" [penumbra]="1" />\n        <ngt-point-light [position]="-10" />\n        // highlight-end\n\n        <demo-cube [position]="[1.5, 0, 0]" />\n        <demo-cube [position]="[-1.5, 0, 0]" />\n    `,\n    imports: [Cube],\n    schemas: [CUSTOM_ELEMENTS_SCHEMA],\n})\nexport class SceneGraph {}\n\n/* AppComponent code */\n')),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"We can always look at ",(0,r.kt)("a",{parentName:"p",href:"https://threejs.org"},"THREE.js")," documentations for details on these THREE.js lights")),(0,r.kt)("p",null,"Our cubes look a lot better now, with dimensionality, showing they ",(0,r.kt)("em",{parentName:"p"},"are")," 3D objects."),(0,r.kt)(l.Z,{srcId:"r8gnez",mdxType:"CodeDemo"}),(0,r.kt)("h2",{id:"bonus-taking-control-of-the-camera"},"Bonus: Taking control of the camera"),(0,r.kt)("p",null,'Who hasn\'t tried to "grab" the scene and move it around? We cannot do that yet as our Camera is ',(0,r.kt)("em",{parentName:"p"},"static")," in its position.\nLet's take over the Camera with ",(0,r.kt)("inlineCode",{parentName:"p"},"OrbitControls"),"."),(0,r.kt)("p",null,"First, let's install ",(0,r.kt)("inlineCode",{parentName:"p"},"three-stdlib"),", which provides ",(0,r.kt)("inlineCode",{parentName:"p"},"OrbitControls")," object"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"npm i three-stdlib\n")),(0,r.kt)("p",null,"Next, we'll update our code as follow"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'/* imports */\n// highlight-next-line\nimport { NgtCanvas, extend, NgtBeforeRenderEvent, NgtStore, NgtArgs } from \'angular-three\';\n// highlight-next-line\nimport { OrbitControls } from \'three-stdlib\';\n\nextend(THREE);\n// highlight-next-line\nextend({ OrbitControls });\n\n/* Cube code */\n\n@Component({\n    standalone: true,\n    template: `\n        <ngt-ambient-light [intensity]="0.5" />\n        <ngt-spot-light [position]="10" [angle]="0.15" [penumbra]="1" />\n        <ngt-point-light [position]="-10" />\n\n        <demo-cube [position]="[1.5, 0, 0]" />\n        <demo-cube [position]="[-1.5, 0, 0]" />\n\n        // highlight-next-line\n        <ngt-orbit-controls *args="[camera, glDom]" [enableDamping]="true" />\n    `,\n    // highlight-next-line\n    imports: [Cube, NgtArgs],\n    schemas: [CUSTOM_ELEMENTS_SCHEMA],\n})\nexport class SceneGraph {\n    // highlight-start\n    private readonly store = inject(NgtStore);\n    readonly camera = this.store.get(\'camera\');\n    readonly glDom = this.store.get(\'gl\', \'domElement\');\n    // highlight-end\n}\n\n/* AppComponent code */\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"We call ",(0,r.kt)("inlineCode",{parentName:"li"},"inject(NgtStore)")," to inject an object which stores all information about the Canvas.",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"We extract ",(0,r.kt)("inlineCode",{parentName:"li"},"camera")," and the ",(0,r.kt)("inlineCode",{parentName:"li"},"gl.domElement")," from the ",(0,r.kt)("inlineCode",{parentName:"li"},"NgtStore")))),(0,r.kt)("li",{parentName:"ul"},"We import ",(0,r.kt)("inlineCode",{parentName:"li"},"OrbitControls")," from ",(0,r.kt)("inlineCode",{parentName:"li"},"three-stdlib")," and call ",(0,r.kt)("inlineCode",{parentName:"li"},"extend()")," with it so our catalogue knows about ",(0,r.kt)("inlineCode",{parentName:"li"},"OrbitControls"),", allowing us to render ",(0,r.kt)("inlineCode",{parentName:"li"},"<ngt-orbit-controls>")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"OrbitControls")," needs two constructor arguments; ",(0,r.kt)("inlineCode",{parentName:"li"},"new OrbitControls(camera, domElement)"),". That's what ",(0,r.kt)("inlineCode",{parentName:"li"},"*args")," directive is for.",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"We set ",(0,r.kt)("inlineCode",{parentName:"li"},"enableDamping")," on the ",(0,r.kt)("inlineCode",{parentName:"li"},"OrbitControls")," to ",(0,r.kt)("inlineCode",{parentName:"li"},"true")," so we have a smooth experience when we move the Camera around.")))),(0,r.kt)(l.Z,{srcId:"gbtvkp",mdxType:"CodeDemo"}),(0,r.kt)("p",null,"That's it! That concludes our tutorial."),(0,r.kt)("h2",{id:"whats-next"},"What's next?"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Try different Geometries, different colors, different Lights"),(0,r.kt)("li",{parentName:"ul"},"Try placing more ",(0,r.kt)("inlineCode",{parentName:"li"},"demo-cube")," in different positions"),(0,r.kt)("li",{parentName:"ul"},"Immerse yourself in THREE.js documentation")))}h.isMDXComponent=!0}}]);